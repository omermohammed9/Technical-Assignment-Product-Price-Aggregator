import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../modules/prisma/prisma.service';
import { GetProductsDto } from './dto/get-products.dto';
import { GetProductChangesDto } from './dto/get-product-changes.dto';
import { EventEmitter } from 'events';

@Injectable()
export class ProductsService {
  private readonly logger = new Logger(ProductsService.name);
  private eventEmitter = new EventEmitter(); // Real-time events

  constructor(private readonly prisma: PrismaService) {}

  /**
   * âœ… Fetch all products with optional filters.
   */
  async getAllProducts(filters: GetProductsDto) {
    this.logger.log(' Filtering products with:', filters);

    const whereClause: any = {
      ...(filters.name && {
        name: { contains: filters.name, mode: 'insensitive' },
      }),
      ...(filters.minPrice && { price: { gte: Number(filters.minPrice) } }),
      ...(filters.maxPrice && { price: { lte: Number(filters.maxPrice) } }),
      ...(typeof filters.availability === 'string' && {
        availability: filters.availability === 'true',
      }),
      ...(filters.provider && {
        provider: { contains: filters.provider, mode: 'insensitive' },
      }),
    };

    return this.prisma.product.findMany({ where: whereClause });
  }

  /**
    Fetch a single product by ID including price history.
   */
  async getProductById(id: number) {
    return this.prisma.product.findUnique({
      where: { id },
      include: { history: true },
    });
  }

  /**
    Fetch products with price or availability changes within a timeframe.
   */
  async getProductChanges(filters: GetProductChangesDto) {
    this.logger.log('ðŸ” Fetching product changes:', filters);

    const whereClause: any = {
      ...(filters.startDate && {
        timestamp: { gte: new Date(filters.startDate) },
      }),
      ...(filters.endDate && { timestamp: { lte: new Date(filters.endDate) } }),
    };

    try {
      return await this.prisma.priceHistory.findMany({
        where: whereClause,
        include: { Product: true },
        orderBy: { timestamp: 'desc' },
      });
    } catch (error) {
      this.logger.error(' Failed to fetch product changes:', error);
      throw new Error('Error fetching product changes');
    }
  }

  /**
    Get the most recent price changes for real-time updates.
   */
  async getLatestChanges() {
    const latestChanges = await this.prisma.priceHistory.findMany({
      take: 5,
      orderBy: { timestamp: 'desc' },
      include: { Product: true },
    });

    return latestChanges.map((change) => ({
      id: change.Product?.id,
      name: change.Product?.name ?? 'Unknown Product',
      oldPrice: change.price,
      newPrice: change.Product?.price ?? 0,
      timestamp: change.timestamp,
    }));
  }

  /**
    Update a product's price & store price history in a single transaction.
   */
  async updateProductPrice(productId: number, newPrice: number) {
    const existingProduct = await this.prisma.product.findUnique({
      where: { id: productId },
    });

    if (!existingProduct) {
      this.logger.warn(`ðŸš¨ Product ID ${productId} not found.`);
      return null;
    }

    if (existingProduct.price === newPrice) {
      this.logger.log(`â„¹ï¸ No price change detected for Product ${productId}.`);
      return existingProduct;
    }

    this.logger.log(
      `ðŸ”” Updating price for Product ${productId} from $${existingProduct.price} to $${newPrice}`,
    );

    // Emit real-time update event
    this.eventEmitter.emit('product-update', {
      id: productId,
      name: existingProduct.name,
      oldPrice: existingProduct.price,
      newPrice,
      timestamp: new Date(),
    });

    return this.prisma.$transaction(async (tx) => {
      // Store price change history
      await tx.priceHistory.create({
        data: { productId: existingProduct.id, price: existingProduct.price },
      });

      // Update the product price
      return tx.product.update({
        where: { id: productId },
        data: { price: newPrice },
      });
    });
  }
}
